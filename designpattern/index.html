---
layout: default
title: Heads first Design Pattern
---

		<div class="Summary">
			<h1> Head First Design Pattern Book Review</h1>
			<p>I had just finished reading the first four chapters of the book:Head First Design Pattern.  Actually, this is the first book that I had read which discusses software design. I really wished I was introduced to this book at an earlier time. The book is easy to read with the way it is written. It discusses technical knowledge in a conversational way to which a reader would most likely remember it. It contains lot of visuals that make learning more effecient. Another notable thing about the book is that it contains question and some activities making it sort of an interactive learning experience rather than having the platonic bombardment of information for readers. Perhaps, in some way, the book was written in an unformal manner with a less professional theme but regardless of which it did not fail to deliver the goal of the book; the readers to learn, as I had learn so much.</p>
			
			<p>I had limited knowledge with OO design principles and these so called “ Design Patterns”. Honestly, I have no idea about it. I do not have a strong foundation of techincal knowledge with programming and this book is the perfect starting point for me. The book preaches the wisdom and lesson learned by other developer on reoccuring problems that can be solved by design patterns . Each pattern starts of with a problem scenario based on real life where you will be part of a company and you need to make a decision on how you would design a system. There is a step by step approach as to why it would be best used. There might be some degree of knowledge required presequite to reading the book as some terms might be unfamiliar to some reader but it is still forgivable. Google up that unfamiliar term and you’re good to go again.  Sometimes all you need to have is know the term that it is called, and from there you can jump start your learning curve by exploring out on your own.</p>
			
			<p>
			Starting of, the book tackled about ‘Strategy Pattern’. The book would then impose you to be part of a company that is working on a duck simulation game. There is a existing design in the system and suddenly the executives wanted to these ducks to be able to fly. The first approached of the narrated developer was just to add fly function then all ducks would just inherit it. But something went wrong as not all ducks should be able to fly. Rubber ducks doens’t fly and then another function of quacking was introduced. This calls to redesign the structure of the system to instead of depending on inheritance, usage of interfaces are introduced. Subsequently after this discussion, the first design principle was introduced by the book. Identify the aspects of your application that vary and separate them from what stays the same. Take what varies and encapsulate it so it won’t affect any other parts of the code adding more flexibility in the system. After doing so, it would follow the second design principle Program to an interface, not an implementation. Part by part, these principles are being integrated into the duck simulation game. I really liked how there would be the logic then it would be converted into a class diagram then it finally be converted into codes, along side with it are comments for beginners to undestand better. Have it in the example below:
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture.PNG" class="center">
			
			<p>
			These figures are pretty much provident all thru out the book. And then the discussion about the Ducks goes on and on until the system is fully optimized. The third design principle is Favor composition over inheritance. These are some of the terms that I kept on hearing about but never fully understand composition before up until now. Okay, maybe even up to know I haven’t take full grasph of these concepts but atleast for now, I am aware of what it is called and all I need to do is try to keep this in practice. From this three design principles, Strategy pattern was derived. The Strategy Pattern defines a family of algorithms,encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. The first chapter was summarized in these image below: 
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture2.png" class="center">
			
			<p>
			Its informative, consice and easy to read. So just incase readers would forget what design pattern is being showcased, reference like these items are present at the end of each chapter.
			
			Moving on to the next Pattern, the ‘Observer’ Pattern. This time, you will be part of a weather monitoring application overview. The challenge in this, is how can we implement a system have that real time update in the most effective way. Here comes the discussion about subscribers between a subject and an observer. Take a look at the illustration below: 
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture3.png" class="center">
			
			<p>
			The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically.  The concept is quite simple especially with how it was correlated with the scenarion of news paper subscription.
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture4.png" class="center">
			
			<p>
			Then shortly after introducing the Observer pattern, the power of loose coupling was tackled. They can interact, but have very little knowledge of each other. Thus the fourth design principle: Strive for loosely coupled designs between objects that interact.
			Applying these principle in mind look at the system design as follow:
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture5.PNG" class="center">
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture5.1.PNG" class="center">
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture5.2.PNG" class="center">
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture5.3.PNG" class="center">
			
			<p>
			Clearly, book did a neat job discussing each part of the code and why is it being integrated in the system. Most resources won’t be as informative as this. The tone of how the message that is being convey to the readers is enjoyable which differ the down right serious on how to handle eventful situations. Additional discusion about Java.until.observable was done, which may be quite helpful but also has its own downside. My take away for this pattern is that I am familiar with ‘observers’ before, but I never really recognized it as a design pattern. I had a similar IoT project when I was in college and we had just mirrored a git project on how to implement it. To my surprise, this is somehow the same way it was implemented. I have a better understanding now of what Observables are.
			
			This concludes the second design pattern:
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture7.png" class="center">
			
			<p>
			
			Notice how the OO Principle is just being added, and the OO pattern is replaced. I think this is an indicator of how each priniciples will commonly be repeated along the different design patterns. 
			The third design pattern is the ‘Decorator Pattern’. This time, the name of the business you are involved with is Starbuzz Coffee. The dilema that you had to face is that your business is growing fast and it needs to update your bevarage. The old system is problematic take a look at this:

			</p>
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture8.1.PNG" class="center">
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture8.PNG" class="center">

			<p>
			With the current design, you are forced to some sort of class explosion if you are not to re-oganize the system structure. Hence, it is suggested to apply the different OO principles to the current situtation. This is where I had started to appriecate short pictures like these whenever they appear in the book:
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture9.png" class="center">
			
			<p>
			
			It is insightful. It gives a sense of reflection on the earlier chapter discussions and how they are related to the current design pattern being discussed. But before moving the the new pattern, the next Design principle is stated: Classes should be open for extension, but closed formodification.  Which basically means, as much as possible our  goal is to allow classes to be easily extended toincorporate new behavior without modifying existing code. Modifying existing codes would more likely cause bugs. And I could not agree more to this statement, it something works, don’t change it unless there is a dire need to restructure it.  Going back to our initail problem, how are we going to fix this. The book suggested us to make use of wrappers and it looks like this: 
			
			</p>
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture10.PNG" class="center">
			
			<p>
			The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. See how the bevarage is wrapped with condiments instead of instantiating lots of different types of bevarages. Upon system restructure, it would now have something like this:
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture11.PNG" class="center">
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture12.PNG" class="center">
			
			<p>
			Like in the previous chapter, topics to reinforce our knowledge were discussed. Java I/O classes are based on decorator patterns. I had used these classes before but it’s just know that I had learned the principle behind it. The book did a great job explaining these things. This concludes the third design Pattern.
			</p>
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture13.png" class="center">
			<p>
			The fourth design pattern is the ‘Factory Pattern’. For this pattern, its like the revisit of the previous design pattern but this time focuses more on encapsulating object creation. The company you that you will be part of is a pizza company that aims to meet maximum flexibility as there is a need for constant change in the system if it is poorly designed. At first, you have a simple code of like this: 
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture14.PNG" class="center">
			
			<p>
			The problem with the existing design is that what if you will add another type of pizza, there will be such need to manually add those chunk of codes, violating the open close principle. Therefore, this is where we would create our simple factory. There is nothing complex about it but merely a type of abstration. Another challenge for the management now is that everyone wants to franchise the pizza store. The same application of factory is then applied on the logic of pizza franchising. The Factory Method Pattern defines an interfacefor creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. Take a look on the illustration below:
			</p>
			<p>
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture15.png" class="center">
			</p>
			<p>
			Factory Method lets subclasses decide which class to instantiate. The pattern allows subclasses themselves to decide at runtime, but because the creator class is written without knowledge of the  ctual products that will be created, which is decided purely by the choice of the subclass that is used. And from here, we can extract yet another design principle: The dependency Inversion Principle. Depend upon abstractions. Do not depend upon concrete classes.  Applying it to our current system it would have something like this:
			</p>
			
				<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture16.png" class="center">
			
			<p>
			Going back to the scenario of the pizza store, a few franchises have been substituting inferior ingredients in their pies to lower costs and increase their margins. To make this happen, the company hadi mplemented an Abstract Factory pattern on thier framework. The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.
			More useful illustrations are as follows comparing what are the difference between factory and abstract factory:
			</p>
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture17.png" class="center">
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture18.png" class="center">
			
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture19.png" class="center">
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture20.png" class="center">
			
			<p>
			These are snapshots of how the solutions are provided in the book. It will give you enough insights on how each pattern is applied in a system. This concludes the fourth design pattern. 
			</p>
			<img src="https://lewisjohnvillamor.github.io/designpattern/images/Capture21.png" class="center">
			
			<p>
			All in all, I can say that the is a good source of fundamental information to those whom would what to know more about the decipline of programmings. It makes you think forward, of which forces you to have your codes be dynamic and systematic as much as possible. I would possibly continue reading the book out of leisure given if time would permit it. I highly recommend this book to my friends whom shares the same interest in developing thier programming knowledge further.
			</p>
			

			<ul class="contacts">
				<li><a href="#">Strategy Pattern</a></li>
				<li><a href="#">Observer Pattern</a></li>
				<li><a href="#">Decorator Pattern</a></li>
				<li><a href="#">Factory Pattern</a></li>
				</ul>
		</div>
